#手把手系列  实战还原一个中等难度的ob变种混淆代码

手把手反混淆系列九：实战还原一个中等难度的ob变种混淆代码

代码来源:

https://thetanuts.org/1518e7fe-980b-47b6-8b93-c98c...

我相信很多人见过这种混淆代码，也相信星球里有很多大佬可以还原。

我这里还原，给还未上手的兄弟指个路。

入门其实不难。

1.打开代码后分析，可以看到十六进制字符串 ，因此我们使用 反混淆模板可以轻易还原。

https://t.zsxq.com/10euhfRMd

2.再次分析后，发现了好几处都有debugger语句，写个代码将其删除:

const removeDeadCode = {
  "EmptyStatement|DebuggerStatement"(path)
  {
  	path.remove();
  },
}

3.继续分析，发现其函数调用有三种不同的形式，为了方便处理，将其统一:

__p_6473343178(134);

__p_6473343178["apply"](undefined, [188])；

__p_6473343178["call"](undefined, 226);

星球里有现成的统一代码，但是直接运行处理不了，因此，我们将其稍作修改就可以了。

注意，这种在处理前，先将属性的访问方式进行统一。

4.继续往下分析，发现好几处可以进行常量折叠，这种直接用插件就可以了。

5.可以明显看到，很多地方调用了  __p_6473343178  这个函数，因此，把这个函数抠出来，然后缺啥补啥，确保它在node下面可以运行。

复制到 ast处理文件，然后还原调用表达式即可。

6.继续往下分析，发现好几处可以进行常量折叠，这种直接用插件就可以了。

7.还原了函数调用，下面基本上没什么好讲的了，为防止大家偷懒，请大家自行完成还原剩下的代码。
手把手反混淆系列九.rar